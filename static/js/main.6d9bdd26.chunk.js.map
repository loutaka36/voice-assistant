{"version":3,"sources":["bluetooth.js","scripts.js","commands.js","App.js","serviceWorker.js","index.js"],"names":["connect","a","async","navigator","bluetooth","requestDevice","filters","name","optionalServices","device","gatt","server","getPrimaryService","service","getCharacteristic","this","characteristic","setState","connectionStatus","commandList","regex","response","greetings","Math","floor","random","length","followUpId","timeOfDay","now","Date","hour","getHours","minutes","getMinutes","exec","writeValue","Uint8Array","returnResponse","inquiry","command","match","followUpList","1","2","returnFollowUpResponse","App","props","state","displayText","inquiring","speechResults","SpeechRecognition","window","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","recognition","createRecognition","baymax","createBaymaxVoice","alert","continuous","interimResults","lang","onstart","console","log","onend","start","onresult","event","result","results","transcript","phrase","SpeechSynthesisUtterance","speak","bind","error","stop","speechSynthesis","abort","className","Button","onClick","React","Component","Boolean","location","hostname","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.6d9bdd26.chunk.js","sourcesContent":["//function for bluetooth connections used in App.js\n\nexport async function connect() {\n  try {\n    let device = await navigator.bluetooth.requestDevice({\n      filters: [\n        {\n          name: 'light',\n        },\n      ],\n      optionalServices: [0x1111]\n    })\n    let server = await device.gatt.connect();\n    let service = await server.getPrimaryService(0x1111);\n    this.characteristic = await service.getCharacteristic(0x2222);\n    this.setState({\n      connectionStatus: 'Device connected'\n    })\n  } catch (err) {\n    // console.log(err)\n    this.setState({\n      connectionStatus: 'Device connection failed'\n    })\n  }\n}\n\n//sends bytes to connected bluetooth device (on position)\nexport async function turnDeviceOn() {\n  try {\n    await this.characteristic.writeValue(\n      new Uint8Array([0xff, 0xff])\n    )\n  } catch (err) {\n    if (err.name === 'TypeError') {\n      return 'Oh no, looks like you don\\'t have a device connected. Try connecting one and try again'\n    } else {\n      return 'Oh no, your device got disconnected'\n    }\n  }\n}\n\n//sends bytes to connected bluetooth device (off position)\nexport async function turnDeviceOff() {\n  try {\n    await this.characteristic.writeValue(\n      new Uint8Array([0x00, 0x00])\n    )\n  } catch (err) {\n    if (err.name === 'TypeError') {\n      return 'Oh no, looks like you don\\'t have a device connected. Try connecting one and try again'\n    } else {\n      return 'Oh no, your device got disconnected'\n    }\n  }\n}\n","export const getTime = () => {\n  const now = new Date()\n  let hour = now.getHours()\n  let minutes = now.getMinutes()\n  let timeOfDay\n  if (hour === 0) {\n    hour = 12\n    timeOfDay = 'AM'\n  } else if (hour < 12) {\n    timeOfDay = \"AM\"\n  } else if (hour === 12) {\n    timeOfDay = 'PM'\n  } else {\n    hour -= 12\n    timeOfDay = 'PM'\n  }\n\n  if (minutes < 10) {\n    minutes= '0' + minutes\n  }\n\n  return `It's currently ${hour}:${minutes} ${timeOfDay}`\n}\n\nexport const getGreeting = () => {\n  const greetings = ['hi there', 'yo yo yo', 'aloha', 'what\\'s good', 'howdy', 'greetings human']\n  return greetings[Math.floor(Math.random() * greetings.length)]\n}\n\n","import {turnDeviceOn, turnDeviceOff} from './bluetooth'\nimport {getTime, getGreeting} from './scripts'\n\nconst commandList = [\n  {\n    regex: /hello|hi|howdy|yo|sup|what's up|hey|aloha/,\n    response: {\n      response: getGreeting,\n    }\n  },\n  {\n    regex: /fist bump/,\n    response: {\n      response: 'FA LALALA',\n    }\n  },\n  {\n    regex: /[\\w\\s]*directions[\\w\\s]*to[\\w\\s]*|[\\w\\s]*navigate[\\w\\s]*to[\\w\\s]*/,\n    response: {\n      response: \"um, I'm not google maps, you can figure that out yourself\",\n    }\n  },\n  {\n    regex: /[\\w\\s]*remind[\\w\\s]*me[\\w\\s]*|[\\w\\s]*set[\\w\\s]*reminder[\\w\\s]*/,\n    response: {\n      response: \"it's not my problem that you're forgetful. why don't you go ask Siri or Alexa to do that for you\",\n    }\n  },\n  {\n    regex: /pain|hurts|hurt/,\n    response: {\n      response: \"on a scale of 1 to 10, how would you rate your pain?\",\n      followUpId: 2\n    }\n  },\n  {\n    regex: /[\\w\\s]*time[\\w\\s]*/,\n    response: {\n      response: getTime,\n    }\n  },\n  {\n    regex: /nevermind|just kidding|no/,\n    response: {\n      response: \"ok, no problem\",\n    }\n  },\n  {\n    regex: /[\\w\\s]*sick[\\w\\s]*/,\n    response: {\n      response: \"oh no, what are you symptoms?\",\n      followUpId: 1\n    }\n  },\n  {\n    regex: /[\\w\\s]*light(?:s)?[\\w\\s]*on[\\w\\s]*|[\\w\\s]*on[\\w\\s]*light(?:s)?[\\w\\s]*/,\n    response: {\n      response: \"ok, I'll turn them on\",\n      exec: turnDeviceOn\n    }\n  },\n  {\n    regex: /[\\w\\s]*light(?:s)?[\\w\\s]*off[\\w\\s]*|[\\w\\s]*off[\\w\\s]*light(?:s)?[\\w\\s]*/,\n    response: {\n      response: \"ok, I'll turn them off\",\n      exec: turnDeviceOff\n    }\n  },\n]\n\nexport const returnResponse = (inquiry) => {\n  for (let command of commandList) {\n    if (inquiry.match(command.regex)) {\n      return command.response\n    }\n  }\n  return {\n    response: 'Sorry, I don\\'t understand what you just said'\n  }\n}\n\nconst followUpList = {\n  1: (inquiry) => {\n    if (inquiry.match(\"head\")) {\n      return \"put some ice on it\"\n    } else {\n      return 'Sorry, I don\\'t know about that. I think WebMD might be able to help you.'\n    }\n  },\n  2: (inquiry) => {\n    if (inquiry.match(/ten|10/)) {\n      return 'that\\'s very severe. Please call an ambulance right away'\n    } else if (inquiry.match(/seven|eight|nine|7|8|9/)){\n      return 'that doesn\\'t sound good. You need to go to a hopsital.'\n    } else if (inquiry.match(/four|five|six|4|5|6/)) {\n      return 'ouch. some pain medications such as advil may help. If you don\\'t see improvement, I would go see a doctor.'\n    } else if (inquiry.match(/one|two|three|1|2|3/)) {\n      return 'doesn\\'t seem too serious. I suggest taking it easy for now.'\n    } else {\n      return 'your response didn\\'t make sense to me. I will assume that you are not hurt'\n    }\n  }\n}\n\nexport const returnFollowUpResponse = (inquiry, followUpId) => {\n  if (followUpList[followUpId]) {\n    return followUpList[followUpId](inquiry)\n  }\n  return 'Sorry, I don\\'t understand what you just said'\n}\n\n\n","import React from 'react';\nimport './App.css';\nimport {returnResponse, returnFollowUpResponse} from './commands'\nimport {connect} from './bluetooth'\nimport {Button} from 'semantic-ui-react'\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      displayText: 'Hi, I am Baymax, your personal assistant. Say \"Hey Baymax\" if you need anything.',\n      inquiring: false,\n      followUpId: null,\n      connectionStatus: 'Device not connected',\n      speechResults: ''\n    }\n\n    const SpeechRecognition = window.SpeechRecognition\n    || window.webkitSpeechRecognition\n    || window.mozSpeechRecognition\n    || window.msSpeechRecognition\n    || window.oSpeechRecognition;\n\n    if (SpeechRecognition != null) {\n      this.recognition = this.createRecognition(SpeechRecognition)\n      this.baymax = this.createBaymaxVoice()\n    } else {\n      window.alert('The current browser does not support the SpeechRecognition API.')\n    }\n\n    this.characteristic = null;\n  }\n\n  createRecognition(SpeechRecognition) {\n    const recognition = new SpeechRecognition();\n    recognition.continuous = true;\n    recognition.interimResults = false;\n    recognition.lang =  'en-US';\n    recognition.onstart = () => {\n      console.log(\"Listening!\")\n    }\n    recognition.onend = () => {\n      console.log(\"Stopping\");\n      this.recognition.start();\n    }\n    recognition.onresult = async event => { //sets up logic for talking back\n      const result = event.results[0][0].transcript;\n      this.setState({\n        speechResults: result\n      })\n      console.log(result);\n\n      if (result === 'hey' && !this.state.inquiring) { //all request must start with 'hey Baymax'\n        let phrase = new SpeechSynthesisUtterance('yes?')\n        this.baymax.speak(phrase)\n        this.setState({\n          displayText: 'Yes?',\n          inquiring: true\n        })\n\n      } else if (this.state.inquiring && !this.state.followUpId) { //if there is not follow up pending\n        let {response, followUpId, exec} = returnResponse(result);\n        if (exec && !followUpId) { //if there is an executable and no followup Id\n          let error = await exec.bind(this)()\n          if (error === 'Oh no, your device got disconnected') {\n            let phrase = new SpeechSynthesisUtterance(error)\n            this.baymax.speak(phrase)\n            this.setState({\n              displayText: error,\n              inquiring: false,\n              connectionStatus: \"Device disconnected\"\n            })\n          } else if (error) {\n            let phrase = new SpeechSynthesisUtterance(error)\n            this.baymax.speak(phrase)\n            this.setState({\n              displayText: error,\n              inquiring: false,\n            })\n          } else {\n            let phrase = new SpeechSynthesisUtterance(response)\n            this.baymax.speak(phrase)\n            this.setState({\n            displayText: response,\n            inquiring: false,\n            })\n          }\n        } else if (exec && followUpId) { // if there is an executable and follow up Id\n          let error = await exec.bind(this)()\n          if (error) {\n            let phrase = new SpeechSynthesisUtterance(error)\n            this.baymax.speak(phrase)\n            this.setState({\n              displayText: error,\n              inquiring: false,\n            })\n          } else {\n            let phrase = new SpeechSynthesisUtterance(response)\n            this.baymax.speak(phrase)\n            this.setState({\n              displayText: response,\n              inquiring: true,\n              followUpId\n            })\n          }\n        } else if (followUpId) {\n          let phrase = new SpeechSynthesisUtterance(response)\n            this.baymax.speak(phrase)\n            this.setState({\n              displayText: response,\n              inquiring: true,\n              followUpId\n            })\n        } else {\n          if (typeof response === 'function') {\n            response = response()\n          }\n          let phrase = new SpeechSynthesisUtterance(response)\n          this.baymax.speak(phrase)\n          this.setState({\n            displayText: response,\n            inquiring: false,\n          })\n        }\n\n      } else if (this.state.inquiring && this.state.followUpId) { //if there is a follow up pending\n        const response = returnFollowUpResponse(result, this.state.followUpId);\n        let phrase = new SpeechSynthesisUtterance(response)\n        this.baymax.speak(phrase)\n        this.setState({\n          displayText: response,\n          inquiring: false,\n          followUpId: null\n        });\n      }\n      this.recognition.stop()\n    }\n    return recognition;\n  }\n\n  createBaymaxVoice() { //creates speech synthesis object\n    const baymax = window.speechSynthesis\n\n    return baymax;\n  }\n\n  componentDidMount() {\n    let phrase = new SpeechSynthesisUtterance('Hi, I am Baymax, your personal assistant. Say \"Hey Baymax\" if you need anything.')\n    this.baymax.speak(phrase)\n    this.recognition.start();\n  }\n\n  componentWillUnmount() {\n    this.recognition.abort()\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"baymax-container\">\n          <div className=\"baymax\"></div>\n          <div className=\"eyelid-top\"></div>\n          <div className=\"eyelid-bottom\"></div>\n        </div>\n        <div>\n          {this.state.displayText}\n        </div>\n        <div className=\"user-input\">\n          <div className=\"user-input_label\">Your Input:</div>\n          <div className=\"user-input_results\">{this.state.speechResults}</div>\n        </div>\n        <div>\n          <Button onClick={connect.bind(this)}>Connect To Device</Button>\n          <div className=\"connection-status\">{this.state.connectionStatus}</div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n\n/* <button onClick={turnDeviceOn.bind(this)}>Turn on</button>\n          <button onClick={turnDeviceOff.bind(this)}>Turn off</button> */\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport 'semantic-ui-css/semantic.min.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}